# FROM FOLLOWING SQLMODEL DOCUMENTATION
# THESE DEFINE STRICT SCHEMAS i.e. how the data is defined/modeled during communication between client, API and DB

from datetime import datetime
from typing import List, Optional

from pydantic import EmailStr
from sqlmodel import (
    Boolean,
    Column,
    DateTime,
    Field,
    ForeignKey,
    Integer,
    Relationship,
    SQLModel,
    text,
)

# step 1: create database tables using pydantic schema
# legacy sqlalchemy can still be imported from sqlmodel and used

# USING MULTIPLE MODELS FOR DATA VALIDATION AND SANITATION
# e.g. when sending to and receiving data from the backend (DB)

# when creating a post, the creator should not give the post an ID,
# it should be autogenerated by the database -> ID should not be included in the POST request

# BUT when the data is queried, it must come with an ID -> ID should be included in the GET request
# and for the DB table, it should have ALL THE DATA needed in both the GET and POST requests

# SOLUTION: use multiple models and inheritance to have a base class with the common
# columns/attributes for the subclasses to inherit

# each schema has title, content and published
class PostBase(SQLModel):
    title: str = Field(index=True)
    # Field(index=True) creates indices for the title column because
    # we will query the database (WHERE) with post titles as parameters
    content: str
    published: Optional[bool] = Field(sa_column=Column(Boolean, server_default="TRUE"))


# this defines what is required from the client to create a valid post
class PostCreate(PostBase):
    # same content as PostBase, no additional fields needed
    pass


# NOTE: this one does not inherit from PostBase but directly from SQLModel, all fields are different
class PostUpdate(SQLModel):
    title: Optional[str] = None
    content: Optional[str] = None
    published: Optional[bool] = None
    rating: Optional[int] = None


class UserBase(SQLModel):
    email: EmailStr = Field(nullable=False, unique=True, index=True)
    name: str


class UserRead(UserBase):
    id: int


class UserCreate(UserBase):
    password: str


class UserLogin(SQLModel):
    email: EmailStr
    name: Optional[str] = None
    password: str


class Token(SQLModel):
    access_token: str
    token_type: str


class TokenPayload(SQLModel):
    id: Optional[str] = None
    name: Optional[str] = None


class VoteReadUsers(SQLModel):
    # has to match the relationship column name in Vote table
    user: UserRead


class PostReadAll(PostBase):
    id: int
    rating: int
    # abusing the power of relationships
    owner: UserRead
    # liked_by: List[VoteReadUsers] = []


class PostOut(SQLModel):
    Post: PostReadAll
    likes: int


class VoteReadPosts(SQLModel):
    likeable_post: PostReadAll


# this is being used as a Response Model i.e. defining what we actually want to send back to the client from the DB
class PostRead(PostReadAll):
    updated_at: str
    pass


class UserReadWithPosts(UserRead):
    # abusing the power of relationships
    posts: List[PostReadAll] = []
    # liked_posts: List[VoteReadPosts] = []


class UserVote(SQLModel):
    post_id: int
    vote_dir: int = Field(ge=0, le=1)


############### ACTUAL DATABASE TABLES ################


class User(UserBase, table=True):
    __tablename__ = "users"
    id: Optional[int] = Field(nullable=False, primary_key=True)
    password: str
    joined_in: Optional[datetime] = Field(
        sa_column=Column(
            DateTime(timezone=True),
            nullable=False,
            server_default=text("now()"),
        )
    )

    posts: List["Post"] = Relationship(back_populates="owner")
    liked_posts: List["Vote"] = Relationship(back_populates="user")


# NOTE: the parameter 'table=True' tells SQLModel that this is a DATABASE TABLE and should be created/loaded onto the DB
class Post(PostBase, table=True):
    __tablename__ = "posts"
    id: Optional[int] = Field(primary_key=True, nullable=False)
    # headache needed to set server-side default values
    rating: Optional[int] = Field(sa_column=Column(Integer, server_default="0"))
    updated_at: Optional[datetime] = Field(
        sa_column=Column(
            DateTime(timezone=True),
            nullable=False,
            server_default=text("now()"),
        )
    )

    # to create a relationship with the users table, declare user id as the foreign key
    # onupdate & ondelete - if any changes to users, they will reflect on posts
    # e.g. if a user is deleted, all their posts are deleted as well
    owner_id: int = Field(
        sa_column=Column(
            Integer,
            ForeignKey(column="users.id", ondelete="cascade", onupdate="cascade"),
            nullable=False,
        )
    )

    # to define a relationship e.g. to extract username from the owner id,
    # create a relationship between the two
    owner: User = Relationship(back_populates="posts")
    liked_by: List["Vote"] = Relationship(back_populates="likeable_post")


class Vote(SQLModel, table=True):
    __tablename__ = "votes"
    post_id: int = Field(
        sa_column=Column(
            Integer,
            ForeignKey(column="posts.id", ondelete="cascade", onupdate="cascade"),
            nullable=False,
            primary_key=True,
        ),
    )
    user_id: int = Field(
        sa_column=Column(
            Integer,
            ForeignKey(column="users.id", ondelete="cascade", onupdate="cascade"),
            nullable=False,
            primary_key=True,
        ),
    )

    user: User = Relationship(back_populates="liked_posts")
    likeable_post: Post = Relationship(back_populates="liked_by")
