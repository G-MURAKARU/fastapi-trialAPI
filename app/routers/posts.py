from datetime import datetime
from typing import List, Optional

from sqlmodel import Session, col, func, select  # or_

# to 'access the app object' from main, FastAPI uses routers
from fastapi import APIRouter, Depends, HTTPException, Response, status

from .. import models, oauth2
from ..database import start_session

# router is not imported from main, use APIRouter
# refactoring, to avoid repeated "/posts"
router = APIRouter(prefix="/posts", tags=["Posts"])

# REMEMBER: FastAPI will execute the first matched path operation (i.e. request + endpoint)

# dummy path operation for retrieving posts (get request)
@router.get("/", response_model=List[models.PostOut])
# @router.get("/")
# specify that we want to return a list of posts
# QUERY PARAMETERS: say we want the user to define how many posts they want to query
# we can set this by passing in an additional parameter to the path operation, which
# will serve as a query parameter indicated by a preceding '?' in the URL
# to chain query parameters, use '&'
def get_posts(
    session: Session = Depends(start_session),
    current_user: models.User = Depends(oauth2.get_current_user),
    limit: int = 10,
    skip: int = 0,
    search: Optional[str] = "",
):
    # USING RAW SQL AND PSYCOPG2 DIRECTLY

    # try:
    #     with psycopg2.connect(
    #         database="FastAPI PracticeDB",
    #         user="postgres",
    #         password="lifegoeson",
    #         host="localhost",
    #         cursor_factory=RealDictCursor,
    #     ) as conn:
    #         with conn.cursor() as cursor:
    #             cursor.execute("""SELECT * FROM \"Posts\"""")
    #             posts = cursor.fetchall()
    #     return {"posts": posts}
    # except psycopg2.OperationalError as error:
    #     print("WE HAVE ENCOUNTERED A MASSIVE ERROR: ", error)

    # USING SQLMODEL ORM AND DB SESSIONS

    # with Session(engine) as session:
    # by using dependencies, the need for a context manager is eliminated

    # query = select(models.Posts) -> selects all from Posts model/table
    # posts_iterable = session.exec(query) -> returns an iterable
    # posts = posts_iterable.all() -> returns a list
    # the above, in one line
    posts = session.exec(
        select(models.Post)
        .limit(limit=limit)
        .offset(offset=skip)
        # to allow for searching by KEYWORD in the TITLE e.g. all posts about formula 1
        .where(col(models.Post.title).contains(search))
    ).all()

    post_likes = session.exec(
        select(models.Post, func.count(models.Vote.post_id).label("likes"))
        .join(models.Vote, isouter=True)
        .group_by(models.Post.id)
    ).all()

    return post_likes


# @app.post("/createposts")
# # Body(...) from FastAPI extracts the body of a http post request, unfurls it and converts
# it to a python dictionary
# def create_post(payload: dict = Body(...)):
#     print(payload)
#     return {"new post": {"title:": payload["title"], "content": payload["content"]}}


# above, refactored with pydantic
# NOTE: the status code in the decorator
@router.post("/", response_model=models.PostRead, status_code=status.HTTP_201_CREATED)
# login enforcement: users have to be logged in so they can create a post
# therefore, to enforce this, use the JWT token that was created -> check if it is in the request header
# and that it is valid
# this is achieved by setting a DEPENDENCY -> get current user fn from oauth2
# for testing, remember to add "Bearer <token>" to the header (note the space)
def create_post(
    post: models.PostCreate,
    session: Session = Depends(start_session),
    current_user: models.User = Depends(oauth2.get_current_user),
):
    """Creates a post"""
    # id is autogenerated in the database, no need to add

    # USING RAW SQL AND PSYCOPG2 DIRECTLY

    # try:
    #     with psycopg2.connect(
    #         database="FastAPI PracticeDB",
    #         user="postgres",
    #         password="lifegoeson",
    #         host="localhost",
    #         cursor_factory=RealDictCursor,
    #     ) as conn:
    #         with conn.cursor() as cursor:
    #             cursor.execute(
    #                 """INSERT INTO \"Posts\" (\"PostTitle\", \"PostContent\", \"PublishedStatus\",
    #                 \"Rating\") VALUES (%s, %s, %s, %s) RETURNING *""",
    #                 (post.title, post.content, post.published, post.rating),
    #             )
    #             new_post = cursor.fetchone()
    #             conn.commit()
    #     return {"new post": new_post}
    # except psycopg2.OperationalError as error:
    #     print("WE HAVE ENCOUNTERED A MASSIVE ERROR: ", error)

    # USING SQLMODEL ORM

    # with Session(engine) as session:
    # by using dependencies, the need for a context manager is eliminated

    # rem: user id comes as a string

    # from SQLModel documentation
    # to add the owner id to the post, use the 'update' keyword argument,
    # passing in the updates that were not sent in the request payload
    new_post = models.Post.from_orm(post, update={"owner_id": current_user.id})
    session.add(new_post)
    session.commit()
    session.refresh(new_post)
    new_post.updated_at = new_post.updated_at.strftime("%d/%m/%Y, %H:%M:%S")

    return new_post


# to retrieve a single post
@router.get("/{post_id}", response_model=models.PostOut)
def get_post(
    post_id: int,
    session: Session = Depends(start_session),
    current_user: models.User = Depends(oauth2.get_current_user),
):
    # USING RAW SQL AND PSYCONG2 DIRECTLY
    # try:
    #     with psycopg2.connect(
    #         database="FastAPI PracticeDB",
    #         user="postgres",
    #         password="lifegoeson",
    #         host="localhost",
    #         cursor_factory=RealDictCursor,
    #     ) as conn:
    #         with conn.cursor() as cursor:
    #             cursor.execute(
    #                 """SELECT * FROM \"posts\" WHERE \"id\" = %s""", (str(post_id),)
    #             )
    #             retrieved_post = cursor.fetchone()
    #             if not retrieved_post:
    #                 raise HTTPException(
    #                     status_code=status.HTTP_404_NOT_FOUND,
    #                     detail="Post (id: {post_id}) Not Found.",
    #                 )
    #             return retrieved_post
    # except psycopg2.OperationalError as error:
    #     perhaps we were unable to connect to the database
    #     print("WE HAVE ENCOUNTERED A MASSIVE ERROR: ", error)

    # USING SQLMODEL ORM

    # with Session(engine) as session:
    # by using dependencies, the need for a context manager is eliminated

    queried_post = session.get(models.Post, post_id)

    queried_post = session.exec(
        select(models.Post, func.count(models.Vote.post_id).label("likes"))
        .where(models.Post.id == post_id)
        .join(models.Vote, isouter=True)
        .group_by(models.Post.id)
    ).one()

    if not queried_post:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Post (id: {post_id}) Not Found.",
        )
    # queried_post.updated_at = queried_post.updated_at.strftime("%Y/%m/%d, %H:%M:%S")

    print(type(queried_post))
    return queried_post


# NOTE: the status code in the decorator
@router.delete("/{post_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_post(
    post_id: int,
    session: Session = Depends(start_session),
    current_user: models.User = Depends(oauth2.get_current_user),
):
    # USING RAW SQL AND PSYCONG2 DIRECTLY

    # try:
    #     with psycopg2.connect(
    #         database="FastAPI PracticeDB",
    #         user="postgres",
    #         password="lifegoeson",
    #         host="localhost",
    #         cursor_factory=RealDictCursor,
    #     ) as conn:
    #         with conn.cursor() as cursor:
    #             cursor.execute(
    #                 """DELETE FROM \"Posts\" WHERE \"id\" = %s RETURNING *""",
    #                 (str(post_id),),
    #             )
    #             deleted_post = cursor.fetchone()
    #     if not deleted_post:
    #         raise HTTPException(
    #             status_code=status.HTTP_404_NOT_FOUND,
    #             detail=f"Post (id: {post_id}) Not Found.",
    #         )
    #     # for a 204, you should not return anything in the response body - just how FastAPI works
    #     return Response(status_code=status.HTTP_204_NO_CONTENT)
    # except psycopg2.OperationalError as error:
    #     print("WE HAVE ENCOUNTERED A MASSIVE ERROR: ", error)

    # USING SQLMODEL ORM

    deleted_post = session.get(models.Post, post_id)
    if not deleted_post:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Post (id: {post_id}) Not Found.",
        )
    if deleted_post.owner_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not your circus, not your monkey.",
        )
    session.delete(deleted_post)
    session.commit()

    # for a 204, you should not return anything in the response body - just how FastAPI works
    return Response(status_code=status.HTTP_204_NO_CONTENT)


@router.patch("/{post_id}", response_model=models.PostRead)
def update_post(
    post_id: int,
    post_to_update: models.PostUpdate,
    session: Session = Depends(start_session),
    current_user: models.User = Depends(oauth2.get_current_user),
):
    # USING RAW SQL AND PSYCONG2 DIRECTLY

    # using a PUT request instead of a PATCH request
    # try:
    #     with psycopg2.connect(
    #         database="FastAPI PracticeDB",
    #         user="postgres",
    #         password="lifegoeson",
    #         host="localhost",
    #         cursor_factory=RealDictCursor,
    #     ) as conn:
    #         with conn.cursor() as cursor:
    #             cursor.execute(
    #                 """UPDATE \"Posts\" SET \"PostTitle\" = %s, \"PostContent\" = %s, \"PublishedStatus\" = %s,
    #                 \"Rating\" = %s WHERE \"id\" = %s RETURNING *""",
    #                 (
    #                     post.title,
    #                     post.content,
    #                     post.published,
    #                     post.rating,
    #                     str(post_id),
    #                 ),
    #             )
    #             updated_post = cursor.fetchone()
    #     if not updated_post:
    #         raise HTTPException(
    #             status_code=status.HTTP_404_NOT_FOUND,
    #             detail=f"Post (id: {post_id}) Not Found.",
    #         )
    #     return {"updated post": updated_post}
    # except psycopg2.OperationalError as error:
    #     print("WE HAVE ENCOUNTERED A MASSIVE ERROR: ", error)

    # USING SQLMODEL ORM
    # using a PATCH request
    updated_post = session.get(models.Post, post_id)
    if not updated_post:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Post (id: {post_id}) Not Found.",
        )
    if updated_post.owner_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not your circus, not your monkey.",
        )

    # to obtain ONLY the data that was sent by the client,
    # ignoring None defaults to prevent unintended overwrite
    post_data = post_to_update.dict(exclude_unset=True)

    # updating the update time to the new time of update
    post_data["updated_at"] = datetime.now()

    # actual updating process
    for key, value in post_data.items():
        # loops through the argument dict, looking for argument keys and setting attribute values
        setattr(updated_post, key, value)

    # 'returning' the updated database entry
    session.add(updated_post)
    session.commit()
    session.refresh(updated_post)
    updated_post.updated_at = updated_post.updated_at.now().strftime(
        "%Y/%m/%d, %H:%M:%S"
    )

    return updated_post
